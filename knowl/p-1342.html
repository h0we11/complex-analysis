<!DOCTYPE html>
<html lang="en-US" dir="ltr">
<!--********************************************-->
<!--*       Generated from PreTeXt source      *-->
<!--*                                          *-->
<!--*         https://pretextbook.org          *-->
<!--*                                          *-->
<!--********************************************-->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="robots" content="noindex, nofollow">
</head>
<body class="ignore-math">
<h3 class="heading"><span class="type">Paragraph</span></h3>
<div class="para logical">
<div class="para">For the function <span class="process-math">\(f_c\text{,}\)</span> defined by <span class="process-math">\(f_c(z) =z^2+c\text{,}\)</span> and an initial seed <span class="process-math">\(z_0\text{,}\)</span> the set of iterates given by <span class="process-math">\(z_1=f_c(z_0)\text{,}\)</span> <span class="process-math">\(z_2=f_c(z_1)\text{,}\)</span> … is also called the orbit of <span class="process-math">\(z_0\)</span> generated by <span class="process-math">\(f_c\text{.}\)</span> We let <span class="process-math">\(K_c\)</span> denote the set of points with a bounded orbit for <span class="process-math">\(f_c\text{.}\)</span> Example 4.9 shows that <span class="process-math">\(K_0\)</span> is the closed unit disk <span class="process-math">\(\overline{D}_1(0)\text{.}\)</span> The boundary of <span class="process-math">\(K_c\)</span> is known as the <em class="emphasis">Julia set</em> for the function <span class="process-math">\(f_c\text{.}\)</span> Thus the Julia set for <span class="process-math">\(f_0\)</span> is the unit circle <span class="process-math">\(C_1(0)\text{.}\)</span> It turns out that <span class="process-math">\(K_c\)</span> is a nice simple set only when <span class="process-math">\(c=0\)</span> or <span class="process-math">\(c=-2\text{;}\)</span> otherwise, <span class="process-math">\(K_c\)</span> is fractal. <a href="" class="xref" data-knowl="./knowl/fig_ch-04-cp-4.html" title="Figure 4.2.9">Figure 4.2.9</a> shows <span class="process-math">\(K_{-1.25}\text{.}\)</span> The variation in colors indicate the length of time it takes for points to become “sufficiently unbounded” according to the following algorithm, which uses the same notation as our algorithm for iterations via Newton’s method. It has reminded some of St. Mark’s square in Venice when flooding occurs.</div>
<ol class="decimal">
<li><div class="para">Compute <span class="process-math">\(f_c(z_{ij})\text{.}\)</span> Continue computing successive iterates of this initial point until the absolute value of one of the iterations exceeds a certain bound (say, <span class="process-math">\(L\)</span>), or until the number of iterations has exceeded a preassigned maximum.</div></li>
<li><div class="para">If Step 1 leaves us with an iteration whose absolute value exceeds <span class="process-math">\(L\)</span> , we color the entire rectangle <span class="process-math">\(R_{ij}\)</span> with a color indicating the number of iterations needed before this value was attained (the more iterations required, the darker the color). Otherwise, we assume that the orbit of the initial point <span class="process-math">\(z_{ij}\)</span> do not diverge to infinity, and we color the entire rectangle black.</div></li>
</ol>
</div>
<span class="incontext"><a href="sec_julia-mandelbrot.html#p-1342" class="internal">in-context</a></span>
</body>
</html>
